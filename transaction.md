# 분산 시스템 환경에서 트랜잭션을 유지하기 위한 방안
## 1. 2PC(Two-Phase Commit)
- 여러 노드들 상에서의 원자적 트랜잭션 커밋을 이루기 위한 프로토콜
- 한 트랜잭션에서 모든 노드가 동일하게 커밋되거나, 모든 노드가 롤백되는 것을 보장하기 위함
- 2PC를 위한 별도의 요소 코디네이터가 필요하다.

### 2PC 동작 Process
1. 트랜잭션이 시작되면 코디네이터가 Transaction ID를 생성 ( Globaly Unique )
2. 코디네이터가 사전에 정의된 트랜잭션 참여 노드에게 이전에 생성한 Transaction ID를 전달 & 트랜잭션 준비(prepare) 요청
3. 코디네이터가 모든 노드들에게 prepare에 대한 요청의 응답을 받으면 트랜잭션을 커밋할지 abort할지 결정
4. prepare 성공 -> 코디네이터가 커밋(commit) 요청 / prepare 실패 -> 코디네이터가 abort 요청
5. 커밋 요청에 대한 응답을 받으면 트랜잭션 종료

### 2PC의 문제점
- 코디네이터에 문제가 발생하는 순간, 모든 트랜잭션관련 비즈니스 정지
- 코디네이터가 commit/rollback에 대한 결정은 취소 불가능
  - ex) 코디네이터가 트랜잭션에 포함된 3개의 노드에 commit을 요청했지만 커밋하는 도중 2개 노드는 성공 1개 노드는 실패 -> 정합성 문제 발생  

## 2. Saga pattern
- 트랜잭션에 참여하는 여러 작업( API 호출 등 )의 결과 이밴트를 발행
- 발행된 이밴트를 컨슘 하는 방식으로 트랜잭션을 처리
- ` 사전에 작업의 순서 & 의존성을 정의 해야함.`

### Saga pattern의 동작 Process
* 사전 정의된 트랜잭션의 순서에 따라 작업을 수행
1. A 서비스 작업 실행 
2. A 서비스 작업 결과 이벤트 발행
3. A 서비스가 발행한 작업결과 이벤트를 B 서비스 컨슘 
4. A 서비스 작업 결과가 정상이면 B 서비스 작업 실행
5. B 서비스 작업 결과 이벤트 발행
6. B 서비스가 발행한 작업결과 이벤트를 C 서비스 컨슘
7. B 서비스 작업 결과가 정상이면 C 서비스 작업 실행
8. C 서비스 트랜잭션 정상 종료 이벤트 발행
9. A 서비스 트랜잭션 최종 종료


### Saga pattern의 종류
* Choreography 
  * 독립적인 오케스트레이터를 두지 않고 saga pattern을 구현
  * 구현이 비교적 간단하지만, 트랜잭션 상황을 모니터링 하기 어렵다.
* Orchestration
  * 독립적인 오케스트레이터를 두고 오케스트레이터가 saga ( 트랜잭션 )에 대한 매니징 담당
  * 구현이 비교적 어렵지만 비교적 전체적인 트랜잭션 모니터링이 수월함.
  
` 이미 commit된 데이터를 commit 이전 상태로 변경하기 위해 기본적으로 Compensating Transaction ( 보상 트랜잭션 ) 사용 `