## 데이터베이스 성능 핵심!!!
* 데이터베이스의 데이터는 결국 디스크에 저장되어야한다.
* 디스크는 메모리에 비해 속도가 훨씬 느리다.
* 결국 데이터베이스 성능의 핵심은 디스크 I/O(접근)을 최소화 하는 것이다.    
  

* 디스크 접근을 줄일수 있는 방법
  * 메모리에 올라온 데이터로 최대한 요청을 처리한다. -> 메모리 캐시 히트율을 높인다.
    * 쓰기도 곧 바로 디스크에 쓰지 않고 메모리에 먼저 쓴다.
    * 메모리에 데이터 유실을 고려해 WAL(Write Ahead Log)를 사용
      * 대부분의 트랜잭션은 무작위하게 Write가 발생함.
      * 이를 지연시켜 랜덤 I/O 횟수를 줄이는 대신 순차적 I/O를 발생시켜 정합성 유지  
  
___
* 결국 데이터베이스 성능에 핵심은 디스크의 랜덤I/O을 최소화 하는 것
 ___

## 인덱스
> 인덱스는 정렬된 자료구조, 이를 통해 탐색범위를 최소화 
> (인덱스도 결국 테이블 이다.)
> 

* 인덱스의 핵심은 탐색(검색) 범위를 최소화 하는 것
* 그렇다면 검색이 빠른 자료구조들은 어떤 것이 있을까?!!!
* Hash Map, List, Binary Search Tree...
  * Hash Map
    * Key, Value 형태
    * 단건 검색 속도 O(1)
    * 그러나 범위 탐색은 O(N)
    * 전방 일치 탐색 불가 ex) like 'AB%'
  * List
    * 정렬되지 않은 리스트의 탐색은 O(N)
    * 정렬된 리스트의 탐색은 O(logN)
    * 정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(N * logN)
    * 삽입 / 삭제 비용이 매우 높음
  * Tree
    * 트리 높이에 따라 시간 복잡도가 결정됨
    * 트리의 높이를 최소화하는 것이 중요!
    * 한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용  
      ex) Red-Black Tree, B+Tree
      * B + Tree 
        * 삽입 / 삭제시 항상 균형을 이룸
        * 하나의 노드가 여러 개의 자식 노드를 가질 수 있음
        * 리프노드에만 데이터 존재
          * 연속적인 데이터 접근 시 유리

## 클러스터 인덱스
> * 클러스터 인덱스는 데이터 위치를 결정한는 키 값이다. 
> * MySQL의 PK는 클러스터 인덱스다.
> * MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.

1. 클러스터 인덱스는 정렬되어 있고, 정렬된 순서에 따라서 데이터의 주소가 결정됨.
   * 클러스터 키 순서에 따라서 데이터 저장 위치가 변경된다.!!!  
    -> 클러스터 키 삽입/갱신시에 성능 이슈 발생
2. PK(클러스터 키) 순서에 따라 데이터 저장 위치가 변경된다.
   * PK 키 삽입/갱신시에 성능 이슈 발생 
3. PK의 사이즈가 인덱스(테이블)의 사이즈를 결정
  * 세컨더리 인덱스만으로는 데이터를 찾아갈 수 없다.  
    -> PK 인덱스를 항상 검색해야함.

### 클러스터 인덱스의 장점
1. PK를 활용한 검색이 빠름. 특히 범위 검색!
2. 세컨더리 인덱스들이 PK를 가지고 있어 커버링에 유리

![image](https://user-images.githubusercontent.com/60100532/202878554-9a15c020-543b-44b3-9694-9c3c32d74d50.png)

![image](https://user-images.githubusercontent.com/60100532/202878614-7cac8cb4-2861-4a86-966b-4abac1567767.png)