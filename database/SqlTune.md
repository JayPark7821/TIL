# 개념적인 튜닝 용어
## 오브젝트 스캔 유형
* 오브젝트 스캔 유형은 테이블 스캔과 인덱스 스캔으로 구분,
* 테이블 스캔은 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근.
* 인덱스 스캔은 인덱스로 테이블 데이터를 찾아가는 유형

### 테이블 풀 스킨
* 테이블 풀 스캔은 인덱스를 거치지 않고 테이블로 바로 직행해 처음부터 끝까지 모든 데이터를 읽는 방식
* where절의 조건문을 기준으로 활용할 수 있는 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 테이블 풀 스캔 방식을 사용
* 테이블 풀 스캔은 테이블의 모든 데이터를 읽어야 하므로 성능측면에서는 부정적

<br />

### 인덱스 범위 스캔
* 인덱스 범위 스캔은 말 그대로 인덱스 범위 기준으로 스캔한 뒤 스캔한 결과를 바탕으로 테이블 데이터 찾아감.
* sql에서 between, in, >, <, like 등의 조건문을 사용할 때 인덱스 범위 스캔이 발생
* 좁은 범위를 스캔할 때는 성능적으로 매우 효율적, 넓은 범위를 스캔할 때는 비효율적인 방식


<br />

### 인덱스 풀 스캔
* 인덱스 풀 스캔은 말 그대로 인덱스를 처음부터 끝까지 모두 스캔하는 방식
* 단, 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 sql 문에서 인덱스 풀 스캔이 수행 됨
* 인덱스 풀 스캔은 테이블에 접근하지 않으므로 테이블 풀 스캔보다는 효율적
* 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 범위를 최대한 줄이는 방향으로 튜닝 필요


<br />

### 인덱스 고유 스캔
* 인덱스 고유 스캔은 기본 키나 고유 인덱스로 테이블에 접근하는 방식.
* 인덱스를 사용하는 스캔 방식 중 가장 효율적 스캔 방법
* where 절에 = 조건으로 작성,해당 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 때 인덱스 고유 스캔이 발생
  
<br />

### 인덱스 루스 스캔
* 인덱스 루스 스캔은 인덱스의 피룡한 부분들만 골라 스캔하는 방식
* 인덱스 범위 스캔처럼 넓은 범위에 전부 접근하지 않고, where절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시
* 인덱스 루스 스캔은 보통 group by 구문이나 max(), min() 함수가 사용된 경우 발생
* `이미 오름차순으로 정렬된 인덱스 에서 최댓값이나 최솟값이 필요한 경우가 이에 해당`

<br />

### 인덱스 병합 스캔
* 인덱스 병합 스캔은 테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식
* where 절에 여러 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와 모두 활용하는 방식을 취함.
* 통합하는 방법으로는 union, intersection방식이 있으며 plan으로 확인 가능
* `인덱스 병합 스캔은 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸림.`
* 따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 sql 튜닝 하거나, sql문 자체를 독립된 하나의 인덱스만 수행하도록 변경하여 튜닝
 


## 응용 용어
### 선택도
* 선택도란 테이블의 특정 열을 기준으로 해당 열의 조건절에 따라 선택되는 데이터 비율을 의미.
* 만약 해당 열에 중복되는 데이터가 많다면 선택도가 높다.
* 해당 열에 중복되는 데이터가 적다면 선택도가 낮다.
* `낮은 선택도를 갖는 열은 데이터를 조회하는 sql문에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할때 주요 고려 대상`
> 선택도 = 선택한 데이터 건수 / 전체 데이터 건수  
> 선택도 = 1 / DISTINCT(count 열명)
> 

### 카디널리티
* 카디널리티의 사전적 정의는 하나의 데이터 유형으로 정의되는 데이터 행의 개수로 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수.
* 현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 활용

> 카디널리티 = 전체 데이터 건수 * 선택도

* 특정 열에 중복된 값이 많다면 카디널리티가 낮고,   
* 해당 열을 조회하면 상당수의 데이터를 거리지 못한 채 대량의 데이터가 출력되리라 예측

| a   | b  |
|-----|----|
| 1   | 1  |
| 1   |2|
| 1   |3|
| 1   |4|
| 1   |5|
| 2   |6|
| 2   |7|
| 2   |8|

* a열의 카디널리티는 낮고,
* b열의 카디널리티는 높다.

### 힌트
* 데이터를 빨리 찾을 수 있게 추가 정보를 전달하는 것
* 힌트는 아래와 같이 사용
```sql
SELECT 컬럼 
FROM 테이블 USE INDEX (인덱스명)
WHERE 조건
```
* 주요 힌트 목록

| 힌트            | 설명                         |
|---------------|----------------------------|
| STRAIGHT_JOIN | from 절에 작성된 테이블 순으로 조인을 유도 |
| USE INDEX     | 특정 인덱스를 사용하도록 유도           |
| IGNORE INDEX  | 특정 인덱스를 사용하지 않도록 유도        | 
| FORCE INDEX   | 특정 인덱스를 사용하도록 강하게 유도       |


* 주의사항 
* 힌트로 특정 인덱스를 사용하라고 명시 했는데 해당 인덱스가 삭제되면 에러 발생함.

# 실행계획
## 기본 실행 계획 항목 분석
### id 
* 실행 순서를 표시하는 숫자. SQL문이 수행되는 차례를 ID로 표기한 것으로, 조인할 때는 똑같은 ID가 표시됨
* ID가 작을수록 먼저 수행된 것이고 ID가 같은 값이면 조인이 이루어졌다고 해석

### select_type
* SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목 
* SELECT 문이 단순히 FROM절에 위치한 것인지, 서브쿼리인지, UNION 절로 묶인 SELECT 문인지 등의 정보 제공

#### | SIMPLE |
* UNION이나 내부 쿼리가 없는 SELECT 문이라는 걸 의미하는 유형입니다. (단순한 SELECT 구문으로만 작성된 경우)

#### | PRIMARY |
* 서브쿼리가 포함된 SQL 문이 있을 때 첫 번쨰 SELECT 문에 해당하는 구문에 표시되는 유형입니다.
* 서브쿼리를 감싸는 외부 쿼리이거나, UNION이 포함된 SQL 문에서 첫 번째로 SELECT 키워드가 작성된 구문에 표시됨.

#### | SUBQUERY |
* 독립적으로 수행되는 서브쿼리를 의미함.
* SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브쿼리일 경우에 해당함

#### | DERIVED |
* FROM 절에 작성된 서브쿼리라는 의미
* FROM 절의 별도 임시 테이블인 인라인 뷰를 말함.

#### | UNION |
* UNION이나 UNION ALL로 묶인 SELECT 문에서 첫 번째 SELECT 구문을 제외한 이후의 SELECT 구문에 해당함
* (UNION구문의 첫 번째 SELECT 절은 PRIMARY 유형으로 표시됨)

#### | UNION RESULT |
* UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력됩니다. 
* UNION은 출력 결과에 중복이 없는 유일한 속성을 가지므로 각 SELECT 절에서 데이터를 가져와 정렬하여 중복 체크하는 과정을 거칩니다. 
* 따라서 UNION RESULT는 별도의 메모리 또는 디스크에 임시 테이블을 만들어 중복을 제거하겠다는 의미로 해석할 수 있다.
* `UNION 구문으로 결합되기 전의 각 SELECT 문이 중복되지 않는 결과가 보장될 때는 UNION 구문 보다는 UNION ALL 구문으로 변경하는 것이 좋다.`

#### | DEPENDENT SUBQUERY |
* UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우
* UNION으로 연결된 단위 쿼리들 중에서 처음으로 작성한 단위 쿼리에 해당하는 경우.
* `UNION으로 연결되는 첫 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조- > 튜닝 대상`

#### | DEPENDENT UNION |
* UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블에 영향을 받는 경우
* UNION으로 연결된 단위 쿼리들 중에서 두 번째 단위 쿼리에 해당되는 경우.
* `UNION으로 연결되는 두 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조- > 튜닝 대상`

#### | UNCACHEABLE SUBQUERY |
* 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형
* 해당 서브쿼리 안에 사용자 정의 함수나 사용자 변수가 포함되거나, RAND(), UUID()함수 등을 사용하여 매번 조회 시 마다 다른 결과를 반환하는 경우
* `만약 자주 호출되는 SQL문이라면 메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 튜닝 고려`

#### | MATERIALIZED |
* IN절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 떄 출력되는 유형.
* 즉 IN 절의 서브쿼리를 임시 테이블로 만들어서 조인 작업을 수행하는 것

### table
* 테이블명을 표시하는 항목
* 실행 계획 정보에서 테이블명이나 테이블 별칭을 출력
* 서브쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 subquery, derived라고 표시됨.


### partitions
* 실행 게획의 부가 정보로, 데이터가 저장된 논리적인 영역을 표시.
* 만약 너무 많은 영역의 파티션에 접근하는 것으로 출력된다면 파티션 정의 튜닝 고려.


### type
* 테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공함
* 테이블을 처음부터 끝까지 전부 확인할지 아니면 인덱스를 통해 바로 데이터를 찾아갈지 등을 해석할 수 있다.

#### | system |
* 테이블에 데이터가 없거나 한 개만 있는 경우로, 성능상 최상의 type이라고 할 수 있습니다.

#### | const |
* 조회되는 데이터가 단 1건일 때 출력되는 유형으로, 성능상 매우 유리한 방식.
* 고유 인덱스나 기본 키를 사용하여 단 1건의 데이터에만 접근하면 되므로 속도나 리소스 사용 측면에서 매우 유리한 방식.

#### | eq_ref |
* 조인이 수행될 떄 드리븐 테이블의 데이터에 접근하며 고유 인덱스 또는 기본 키로 단 1건의 데이터를 조회하는 방식.
* 드라이빙 테이블과의 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 떄 성능상 가장 유리.

#### | ref |
* 조인을 수행할 떄 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미
* 즉 조인이 수행될때 일대다 관계가 되므로, 드라이빙 테이블의 1개 값이 드리븐 테이블에서는 2개 이상의 데이터로 존재함.
* 기본 키나 고유 인덱스를 활용하면 2개 이상의 데이터가 검색되거나, 유일성 없는 비고유 ㅇ니덱스를 사용하게 된다.
* 드리븐 테이블의 데이터 양이 많지 않을때는 성능 저하를 크게 우려하지 않아도 되지만,
* 데이터양이 많다면 접근해야 할 데이터 범위가 넓어져 성능 저하의 원인이 되는지 확인해야함.
* 한편으로 =,<,> 등의 연산자를 사용해 인덱스로 생성된 열을 비교할 떄도 출력됨.

#### | ref_or_null |
* ref 유형과 유사하지만 IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식.
* MySQL과 MariaBD는 NULL에 대해서도 인덱스를 활용하여 검색할 수 있으며, 이때 NULL은 사장 앞쪽에 정렬됨.
* 테이블에 검색할 NULL 데이터양이 적다면 ref_of_null 방식을 활용했을 때 효율적인 SQL문이 될 것이나, 
* 검색할 NULL 데이터양이 많다면 튜닝의 대상

#### | range |
* 테이블 내의 연속된 데이터 범위를 조회하는 유형
* 주어진 데이터 범위 내에서 행 단위로 스캔하지만, 스캔할 범위가 넓으면 성능 저하의 요인이 될 수 있음

#### | fulltext |
* 텍스트 검색을 빠르게 처리하기 위해 전문 인덱스를 사용하여 데이터에 접근하는 방식

#### | index_merge |
* 결합된 인덱스들이 동시에 사용된든 유형입니다.
* `특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용됩니다.( 전문 인덱스 제외)` 

#### | index |
* type 항목의 index 유형은 인덱스 풀 스캔을 의미한다.
* 즉 물리적인 인덱스 블록을 처음부터 끝까지 훑는 방식
* 보통 인덱스는 테이블보다 크기가 작으므로 테이블 풀 스캔 방식보다는 빠를 가능성이 높다.

#### | ALL |
* 테이블을 처음부터 끝까지 ㅇ릭는 테이블 풀 스캔 방식에 해당됨.
* All 유형은 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는게 오히려 비효율적이라고 옵티마이저가 판단했을때 선택
* `All 유형일 때는 인덱스를 새로 추가하거나 기존 익덱스를 변경하여 인덱스를 활용하도록 튜닝`
* `전체 테이블중 10~20% 이상의 데이터를 검색해야 한다면 All 유형이 나올 가능성이 높음.`

### possible_keys
* 옵티마이저가 sql문을 최적화하고자 사용할 수 있는 인덱스 목록을 출력
* 사용할 수 있는 후보군의 기본 키와 인덱스 목록만 보여주므로 튜닝의 효용성은 없음.

### key
* 옵티마이저가 sql문을 최적화 하고자 선택한 기본키(PK) 또는 인덱스명을 출력
* 비효율적인 인덱스나, 인덱스 자체를 사용하지 않았다면 튜닝 대상

### key_len
* 인덱스를 사용할 때는 인덱스 전체를 사용하거나 일부 인덱스만 사용합니다. 
* key_len은 이렇게 사용한 인덱스의 바이트 수를 의미함.
* UTF-8 캐릭터셋 기준으로 INT 4바이트, VARCHAR 3바이트

### ref
* 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 액세스 되었는지를 알려주는 정보.

### row
* sql문을 수행하고자 접근하는 데이터의 모든 행 수를 나타내는 예측 항목.
* `sql문의 최종 결과 건수와 비교해 rows수가 크게 차이 날 떄는 불필요하게 MySQL엔진까지 데이터를 많이 가져왔다는 뜻 -> 튜닝 대상`

### filtered
* sql문을 통해 DB 엔진으로 가져온 데이터 대상으로 필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지를 의미하는 항목.
* DB엔진으로 100건의 데이터를 가져왔다고 가졍했을때 조건에의해 10건이 필터링 되었다면 100/10 = 10 이라는 정보가 출력

### Extra
* sql문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목




# Sql Tuning
## 실무적인 SQL 튜닝 절차 이해하기
* SQL 문의 구성요소는 크게 두 가지로 구분할 수 있다.
* 가시적으로는 테이블 현황, 조건절, 그루핑 열, 정렬되는 열, select 절의 열 등이 있고,
* 비 가시적으로는 실행 계획, 인덱스 현황, 조건절 열들의 데이터 분포, 데이터의 적재 속도, 업무 특성등이 있다.

1. sql문 실행결과 & 현황 파악
    * 결과 및 소요시간 확인.
    * 조인/서브쿼리 구조
    * 동등/범위 조건
2. 가시적, 비 가시적 요소 파악
    * 가시적 : 테이블의 데이터 건수, select절 컬럼 분석, 조건절 컬럼 분석, 그루핑/정렬 컬럼
    * 비가시적 : 실행 계획, 인덱스 현황, 데이터 변경 추이, 업무적 특징.
3. 튜닝 방향 판단 & 개선/적용


### 기본 키를 변형하는 sql문
#### 현황 분석
* | 튜닝 전 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220267490-76b226ec-b48a-49fb-ba37-69a210a8e8e1.png)
* | 튜닝 전 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220267753-a009dede-c1b2-4d3a-898d-93cc28ed9019.png)

#### 튜닝 수행
* | 데이터 확인 |
  ![image](https://user-images.githubusercontent.com/60100532/220268027-48959575-be69-4508-b370-46bc1139244c.png)
* | index 확인 |
  ![image](https://user-images.githubusercontent.com/60100532/220268355-3c391226-6abe-4886-8b22-a9b20994b516.png)

* 튜닝 전 sql 문에서는 사원번호 열(기본키)을 where절 조건으로 작성했지만   
  substring(사원번호,1,4)와 length(사원번호)와 같이 가공하여 사용했으므로
* 기본키를 사용하지 못하고 테이블 풀 스캔(Type ALL)을 수행하게 됨
* 따라서 가공된 사원번호 열을 변경하여 기본 키를 사용할 수 있도록 튜닝.

#### 튜닝 결과
* | 튜닝 후 SQL 문 |
    * 기존 가공되어 사용되던 사원번호(기본키)를 변형없이 사용하도록 변경
    * ![image](https://user-images.githubusercontent.com/60100532/220269424-2b70dc32-d10b-4de2-9990-461a7f5af502.png)
* | 튜닝 후 실행 계획 |
    * ![image](https://user-images.githubusercontent.com/60100532/220269793-131e9adb-4928-4936-9b68-02224415e062.png)
    * where 절의 between 구문에 의해 기본키 (key : primary)의 특정 범위 스캔(type : range)
    * 출력할 사원번호가 10개 이므로 rows항목에서도 10이라는 값을 출력


---

### 사용하지 않는 함수를 포함하는 sql문
#### 현황 분석
* | 튜닝 전 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220271368-8629b97f-1fba-48a5-b030-3c0b489f7623.png)
* | 튜닝 전 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220271773-b1052128-7b65-4213-89e1-1823dd85237b.png)
* key 항목이 I_성별_성 , type 항목이 index
* 즉 I_성별_성 인덱스를 활용해 인덱스 풀스캔 수행
* 또한 extra에 Using temporary, Using filesort가 표시되어 있음 -> 임시 테이블 생성 및 정렬 수행.

#### 튜닝 수행
* 성별 컬럼은 not null
  ![image](https://user-images.githubusercontent.com/60100532/220273581-3965b108-947d-45d0-b97c-ca225371467b.png)
* 따라서 ifnull() 함수를 처리하려고 DB 내부적으로 별도의 임시 테이블을 만들어서 null값 예외처리를 필요 없음.

#### 튜닝 결과
* | 튜닝 후 SQL 문 |
    * ifnull() 함수를 제거하고 성별 열만 그대로 사용하여 튜닝한 쿼리.
    * ![image](https://user-images.githubusercontent.com/60100532/220273991-ca0c3b87-3e4c-4c45-8d62-9f2dabd9d2e1.png)
* | 튜닝 후 실행 계획 |
    * ![image](https://user-images.githubusercontent.com/60100532/220275374-df16838c-37a7-4b1c-985b-966f9648c4da.png)
    * key 항목이 I_성별_성 , type 항목이 index
    * 즉 I_성별_성 인덱스를 활용해 인덱스 풀스캔 수행.
    * extra 항목에 Using index가 표시되어 있음 -> 인덱스 풀 스캔 수행. (기존 임시 테이블 없이)

---

### 형변환으로 인덱스를 활용하지 못하는 sql문
#### 현황 분석
* | 튜닝 전 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220276171-0dc92fb9-e621-4d92-9be3-ad308ba356ae.png)
* | 튜닝 전 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220278858-aa7a6e96-108d-492d-9a22-5b6f49b9a0f8.png)
    * key 항목 I_사용여부, type 항목 index
    * I_사용여부 인덱스를 활용해 인덱스 풀스캔 수행
    * rows 항목 449385 즉 스토리지 엔진에서 449385건을 읽어와 42842으로 필터링해 출력함.
    * 스토리지 엔진에서 불필요한 I/O 발생.


#### 튜닝 수행
* 데이터 확인
  ![image](https://user-images.githubusercontent.com/60100532/220285934-e841dd65-db5b-4ff1-a3b4-7580f72f697f.png)
* 사용여부 컬럼 값이 1인 데이터는 전체 데이터 대비 2% 미만.
  ![image](https://user-images.githubusercontent.com/60100532/220286646-1b6d3983-b2ca-47f4-8f68-854616c94dec.png)
* 사용여부 열 type은 문자형인 char(1) 즉 where 사원번호 = 1과 같이 숫자 유형으로 데이터에 접근해
* 내부적으로 형변환이 발생 -> 그결과 I_사용여부 인덱스를 제대로 활용하지 못함.

#### 튜닝 결과
* | 튜닝 후 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220287068-88018c18-56d4-4520-84b5-c2d6818640ca.png)
* | 튜닝 후 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220287350-c0229f99-4910-4050-9d9b-631686977f75.png)
    * 스토리지 엔진에서 가져온 데이터 건수가 85682건으로 줄어듬. 스토리지 엔진 I/O감소

---

### 열을 결합하여 사용하는 sql문
#### 현황 분석
* | 튜닝 전 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220290622-5734d970-5386-4891-8204-eca5257119e6.png)
  ![image](https://user-images.githubusercontent.com/60100532/220290731-efaf7bd7-947d-4b9a-bc94-d6237cc7626c.png)
* | 튜닝 전 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220290883-dcbf720d-8683-473b-86df-68535ee16f63.png)
    * type 항목 ALL
    * 테이블 풀스캔
    * rows 항목 298980 즉 스토리지 엔진에서 298980건을 읽어와 102건 으로 필터링해 출력함.


#### 튜닝 수행
* 데이터 확인
  ![image](https://user-images.githubusercontent.com/60100532/220291468-e02b7213-688c-45ea-b64b-2aed9062ee2e.png)
* 인덱스 확인
  ![image](https://user-images.githubusercontent.com/60100532/220292061-15e157cf-6f29-46f1-9963-8cc3c7b6075d.png)
    * 성별 열과 성 열로 구성된 I_성별_성 인덱스 사용가능.
    * 조건문도 동등 조건(=)이므로 인덱스를 활용하여 빠르게 조회 가능.

#### 튜닝 결과
* | 튜닝 후 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220292766-4ba99490-e689-4972-bafb-1e8d4a0fcc1b.png)
  ![image](https://user-images.githubusercontent.com/60100532/220292845-8b8172f6-9393-4755-a361-6b461c845592.png)
* | 튜닝 후 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220293012-70ef8a35-f7c4-4671-9ef7-f31660cbac74.png)
    * key 항목 I_성별_성 인덱스 사용
    * rows 항목 튜닝 전 298980건에서 102건으로 줄어듬. 데이터 엑세스 범위 줄어듬.
---

### 습관적으로 중복을 제거하는 sql문
#### 현황 분석
* | 튜닝 전 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220299598-342ae95d-8f33-445f-bd2c-51ff358f3416.png)
  ![image](https://user-images.githubusercontent.com/60100532/220299703-ce9428d2-6618-4a1e-b550-12d92b4cf73c.png)

* | 튜닝 전 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220299839-8cdc66ad-af09-47af-b344-0cff233a4a58.png)
    * 드라이빙 테이블인 부서관리자 테이블과 드리븐 테이블인 사원 테이블의 id값이 1로 동일함 -> 서로 조인
    * 드라이빙 테이블 부서관리자 테이블의 type 항목 index -> 인덱스 풀스캔
    * 드리븐 테이블 사원 테이블의 type 항목 eq_ref ->  사원번호를 사용해 1건의 데이터를 조회하는 방식으로 조인
    * extra 항목에 Using temporary -별도 임시 테이블 만들고 있음. -> 튜닝 대상
#### 튜닝 수행
* 사원 테이블의 기본 키는 사원번호. -> 사원.사원번호에는 중복된 데이터 없음.
* distinct 키워드 사용할 필요 고민....
> distinct는 나열된 열들을 정렬한 뒤 중복된 데이터는 삭제함.
> distinct를 쿼리에 작성하는 것만으로도 정렬 작업이 포함됨.

#### 튜닝 결과
* | 튜닝 후 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220302240-ce7ee7e8-26e0-4c08-8f4f-32394273d9e2.png)
  ![image](https://user-images.githubusercontent.com/60100532/220302286-f905e1dc-fb37-41d9-92aa-8e59ca5f3151.png)
    * 필요없는 distinct 키워드 제거
* | 튜닝 후 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220302591-2752bacf-5ad2-4842-98fc-0b60c2f21418.png)
    * extra 항목의 Using temporary 제거됨
---


### 다수 쿼리를 UNION 연산자로만 합치는 sql문
#### 현황 분석
* | 튜닝 전 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220304194-0232565e-cc49-4096-a204-c4895d99ac12.png)
  ![image](https://user-images.githubusercontent.com/60100532/220304233-c8d7436c-da36-40a0-bb6c-f3617ae7490f.png)
* | 튜닝 전 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220304354-77b3f0d9-9a7b-41ff-b448-b5d14d0e6779.png)
#### 튜닝 수행
* 두 개의 select 문이 UNION 연산자로 통합되는 과정에서 각 select 문의 결과를 합친 뒤 중복을 제거하고 그 결과를 출력함.
* 이미 사원번호라는 기본 키가 출력되는 sql문에서 이처럼 중복 제거가 필요한지 고민해야 함.

#### 튜닝 결과
* | 튜닝 후 SQL 문 |
  ![image](https://user-images.githubusercontent.com/60100532/220309605-089a0631-1df1-4a33-ad47-4f257be92d4c.png)
  ![image](https://user-images.githubusercontent.com/60100532/220309676-385004fd-6411-4d7c-83ce-a26916e164c7.png)
    * union -> union all 변경

* | 튜닝 후 실행 계획 |
  ![image](https://user-images.githubusercontent.com/60100532/220309852-b1f59539-99b8-440a-8214-6fb50a5f2c02.png)
    * 이전 실행 계획과 달리 id가 1,2의 결과를 단순히 합칠 뿐이므로 세 번째 추가 행은 필요하지 않음.
    * 즉 정렬하여 중복을 제거하는 작업이 제외되면서 불필요한 리소스 낭비 방지.

> UNION ALL 과 UNION의 차이
> * UNION ALL은 여러 개의 SELECT 문을 실행하는 결과를 단수히 합치는 것에 그치지만,   
    > UNION은 여러개의 SELECT 문의 실행 결과를 합친 뒤 중복된 데이터를 제거하는 작업까지 포함함.
---