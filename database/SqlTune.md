# 개념적인 튜닝 용어
## 오브젝트 스캔 유형
* 오브젝트 스캔 유형은 테이블 스캔과 인덱스 스캔으로 구분,
* 테이블 스캔은 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근.
* 인덱스 스캔은 인덱스로 테이블 데이터를 찾아가는 유형

### 테이블 풀 스킨
* 테이블 풀 스캔은 인덱스를 거치지 않고 테이블로 바로 직행해 처음부터 끝까지 모든 데이터를 읽는 방식
* where절의 조건문을 기준으로 활용할 수 있는 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 테이블 풀 스캔 방식을 사용
* 테이블 풀 스캔은 테이블의 모든 데이터를 읽어야 하므로 성능측면에서는 부정적

<br />

### 인덱스 범위 스캔
* 인덱스 범위 스캔은 말 그대로 인덱스 범위 기준으로 스캔한 뒤 스캔한 결과를 바탕으로 테이블 데이터 찾아감.
* sql에서 between, in, >, <, like 등의 조건문을 사용할 때 인덱스 범위 스캔이 발생
* 좁은 범위를 스캔할 때는 성능적으로 매우 효율적, 넓은 범위를 스캔할 때는 비효율적인 방식


<br />

### 인덱스 풀 스캔
* 인덱스 풀 스캔은 말 그대로 인덱스를 처음부터 끝까지 모두 스캔하는 방식
* 단, 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 sql 문에서 인덱스 풀 스캔이 수행 됨
* 인덱스 풀 스캔은 테이블에 접근하지 않으므로 테이블 풀 스캔보다는 효율적
* 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 범위를 최대한 줄이는 방향으로 튜닝 필요


<br />

### 인덱스 고유 스캔
* 인덱스 고유 스캔은 기본 키나 고유 인덱스로 테이블에 접근하는 방식.
* 인덱스를 사용하는 스캔 방식 중 가장 효율적 스캔 방법
* where 절에 = 조건으로 작성,해당 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 때 인덱스 고유 스캔이 발생
  
<br />

### 인덱스 루스 스캔
* 인덱스 루스 스캔은 인덱스의 피룡한 부분들만 골라 스캔하는 방식
* 인덱스 범위 스캔처럼 넓은 범위에 전부 접근하지 않고, where절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시
* 인덱스 루스 스캔은 보통 group by 구문이나 max(), min() 함수가 사용된 경우 발생
* `이미 오름차순으로 정렬된 인덱스 에서 최댓값이나 최솟값이 필요한 경우가 이에 해당`

<br />

### 인덱스 병합 스캔
* 인덱스 병합 스캔은 테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식
* where 절에 여러 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와 모두 활용하는 방식을 취함.
* 통합하는 방법으로는 union, intersection방식이 있으며 plan으로 확인 가능
* `인덱스 병합 스캔은 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸림.`
* 따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 sql 튜닝 하거나, sql문 자체를 독립된 하나의 인덱스만 수행하도록 변경하여 튜닝
 


## 응용 용어
### 선택도
* 선택도란 테이블의 특정 열을 기준으로 해당 열의 조건절에 따라 선택되는 데이터 비율을 의미.
* 만약 해당 열에 중복되는 데이터가 많다면 선택도가 높다.
* 해당 열에 중복되는 데이터가 적다면 선택도가 낮다.
* `낮은 선택도를 갖는 열은 데이터를 조회하는 sql문에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할때 주요 고려 대상`
> 선택도 = 선택한 데이터 건수 / 전체 데이터 건수  
> 선택도 = 1 / DISTINCT(count 열명)
> 

### 카디널리티
* 카디널리티의 사전적 정의는 하나의 데이터 유형으로 정의되는 데이터 행의 개수로 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수.
* 현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 활용

> 카디널리티 = 전체 데이터 건수 * 선택도

* 특정 열에 중복된 값이 많다면 카디널리티가 낮고,   
* 해당 열을 조회하면 상당수의 데이터를 거리지 못한 채 대량의 데이터가 출력되리라 예측

| a   | b  |
|-----|----|
| 1   | 1  |
| 1   |2|
| 1   |3|
| 1   |4|
| 1   |5|
| 2   |6|
| 2   |7|
| 2   |8|

* a열의 카디널리티는 낮고,
* b열의 카디널리티는 높다.

### 힌트
* 데이터를 빨리 찾을 수 있게 추가 정보를 전달하는 것
* 힌트는 아래와 같이 사용
```sql
SELECT 컬럼 
FROM 테이블 USE INDEX (인덱스명)
WHERE 조건
```
* 주요 힌트 목록

| 힌트            | 설명                         |
|---------------|----------------------------|
| STRAIGHT_JOIN | from 절에 작성된 테이블 순으로 조인을 유도 |
| USE INDEX     | 특정 인덱스를 사용하도록 유도           |
| IGNORE INDEX  | 특정 인덱스를 사용하지 않도록 유도        | 
| FORCE INDEX   | 특정 인덱스를 사용하도록 강하게 유도       |


* 주의사항 
* 힌트로 특정 인덱스를 사용하라고 명시 했는데 해당 인덱스가 삭제되면 에러 발생함.

# 실행계획
## 기본 실행 계획 항목 분석
### id 
* 실행 순서를 표시하는 숫자. SQL문이 수행되는 차례를 ID로 표기한 것으로, 조인할 때는 똑같은 ID가 표시됨
* ID가 작을수록 먼저 수행된 것이고 ID가 같은 값이면 조인이 이루어졌다고 해석

### select_type
* SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목 
* SELECT 문이 단순히 FROM절에 위치한 것인지, 서브쿼리인지, UNION 절로 묶인 SELECT 문인지 등의 정보 제공

#### | SIMPLE |
* UNION이나 내부 쿼리가 없는 SELECT 문이라는 걸 의미하는 유형입니다. (단순한 SELECT 구문으로만 작성된 경우)

#### | PRIMARY |
* 서브쿼리가 포함된 SQL 문이 있을 때 첫 번쨰 SELECT 문에 해당하는 구문에 표시되는 유형입니다.
* 서브쿼리를 감싸는 외부 쿼리이거나, UNION이 포함된 SQL 문에서 첫 번째로 SELECT 키워드가 작성된 구문에 표시됨.

#### | SUBQUERY |
* 독립적으로 수행되는 서브쿼리를 의미함.
* SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브쿼리일 경우에 해당함

#### | DERIVED |
* FROM 절에 작성된 서브쿼리라는 의미
* FROM 절의 별도 임시 테이블인 인라인 뷰를 말함.

#### | UNION |
* UNION이나 UNION ALL로 묶인 SELECT 문에서 첫 번째 SELECT 구문을 제외한 이후의 SELECT 구문에 해당함
* (UNION구문의 첫 번째 SELECT 절은 PRIMARY 유형으로 표시됨)

#### | UNION RESULT |
* UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력됩니다. 
* UNION은 출력 결과에 중복이 없는 유일한 속성을 가지므로 각 SELECT 절에서 데이터를 가져와 정렬하여 중복 체크하는 과정을 거칩니다. 
* 따라서 UNION RESULT는 별도의 메모리 또는 디스크에 임시 테이블을 만들어 중복을 제거하겠다는 의미로 해석할 수 있다.
* `UNION 구문으로 결합되기 전의 각 SELECT 문이 중복되지 않는 결과가 보장될 때는 UNION 구문 보다는 UNION ALL 구문으로 변경하는 것이 좋다.`

#### | DEPENDENT SUBQUERY |
* UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우
* UNION으로 연결된 단위 쿼리들 중에서 처음으로 작성한 단위 쿼리에 해당하는 경우.
* `UNION으로 연결되는 첫 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조- > 튜닝 대상`

#### | DEPENDENT UNION |
* UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블에 영향을 받는 경우
* UNION으로 연결된 단위 쿼리들 중에서 두 번째 단위 쿼리에 해당되는 경우.
* `UNION으로 연결되는 두 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조- > 튜닝 대상`

#### | UNCACHEABLE SUBQUERY |
* 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형
* 해당 서브쿼리 안에 사용자 정의 함수나 사용자 변수가 포함되거나, RAND(), UUID()함수 등을 사용하여 매번 조회 시 마다 다른 결과를 반환하는 경우
* `만약 자주 호출되는 SQL문이라면 메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 튜닝 고려`

#### | MATERIALIZED |
* IN절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 떄 출력되는 유형.
* 즉 IN 절의 서브쿼리를 임시 테이블로 만들어서 조인 작업을 수행하는 것

### table
* 테이블명을 표시하는 항목
* 실행 계획 정보에서 테이블명이나 테이블 별칭을 출력
* 서브쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 subquery, derived라고 표시됨.


### partitions
* 실행 게획의 부가 정보로, 데이터가 저장된 논리적인 영역을 표시.
* 만약 너무 많은 영역의 파티션에 접근하는 것으로 출력된다면 파티션 정의 튜닝 고려.


### type
* 테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공함
* 테이블을 처음부터 끝까지 전부 확인할지 아니면 인덱스를 통해 바로 데이터를 찾아갈지 등을 해석할 수 있다.

#### | system |
* 테이블에 데이터가 없거나 한 개만 있는 경우로, 성능상 최상의 type이라고 할 수 있습니다.

#### | const |
* 조회되는 데이터가 단 1건일 때 출력되는 유형으로, 성능상 매우 유리한 방식.
* 고유 인덱스나 기본 키를 사용하여 단 1건의 데이터에만 접근하면 되므로 속도나 리소스 사용 측면에서 매우 유리한 방식.

#### | eq_ref |
* 조인이 수행될 떄 드리븐 테이블의 데이터에 접근하며 고유 인덱스 또는 기본 키로 단 1건의 데이터를 조회하는 방식.
* 드라이빙 테이블과의 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 떄 성능상 가장 유리.

#### | ref |
* 조인을 수행할 떄 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미
* 즉 조인이 수행될때 일대다 관계가 되므로, 드라이빙 테이블의 1개 값이 드리븐 테이블에서는 2개 이상의 데이터로 존재함.
* 기본 키나 고유 인덱스를 활용하면 2개 이상의 데이터가 검색되거나, 유일성 없는 비고유 ㅇ니덱스를 사용하게 된다.
* 드리븐 테이블의 데이터 양이 많지 않을때는 성능 저하를 크게 우려하지 않아도 되지만,
* 데이터양이 많다면 접근해야 할 데이터 범위가 넓어져 성능 저하의 원인이 되는지 확인해야함.
* 한편으로 =,<,> 등의 연산자를 사용해 인덱스로 생성된 열을 비교할 떄도 출력됨.

#### | ref_or_null |
* ref 유형과 유사하지만 IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식.
* MySQL과 MariaBD는 NULL에 대해서도 인덱스를 활용하여 검색할 수 있으며, 이때 NULL은 사장 앞쪽에 정렬됨.
* 테이블에 검색할 NULL 데이터양이 적다면 ref_of_null 방식을 활용했을 때 효율적인 SQL문이 될 것이나, 
* 검색할 NULL 데이터양이 많다면 튜닝의 대상

#### | range |
* 테이블 내의 연속된 데이터 범위를 조회하는 유형
* 주어진 데이터 범위 내에서 행 단위로 스캔하지만, 스캔할 범위가 넓으면 성능 저하의 요인이 될 수 있음

#### | fulltext |
* 텍스트 검색을 빠르게 처리하기 위해 전문 인덱스를 사용하여 데이터에 접근하는 방식

#### | index_merge |
* 결합된 인덱스들이 동시에 사용된든 유형입니다.
* `특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용됩니다.( 전문 인덱스 제외)` 

#### | index |
* type 항목의 index 유형은 인덱스 풀 스캔을 의미한다.
* 즉 물리적인 인덱스 블록을 처음부터 끝까지 훑는 방식
* 보통 인덱스는 테이블보다 크기가 작으므로 테이블 풀 스캔 방식보다는 빠를 가능성이 높다.

#### | ALL |
* 테이블을 처음부터 끝까지 ㅇ릭는 테이블 풀 스캔 방식에 해당됨.
* All 유형은 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는게 오히려 비효율적이라고 옵티마이저가 판단했을때 선택
* `All 유형일 때는 인덱스를 새로 추가하거나 기존 익덱스를 변경하여 인덱스를 활용하도록 튜닝`
* `전체 테이블중 10~20% 이상의 데이터를 검색해야 한다면 All 유형이 나올 가능성이 높음.`

### possible_keys
* 옵티마이저가 sql문을 최적화하고자 사용할 수 있는 인덱스 목록을 출력
* 사용할 수 있는 후보군의 기본 키와 인덱스 목록만 보여주므로 튜닝의 효용성은 없음.

### key
* 옵티마이저가 sql문을 최적화 하고자 선택한 기본키(PK) 또는 인덱스명을 출력
* 비효율적인 인덱스나, 인덱스 자체를 사용하지 않았다면 튜닝 대상

### key_len
* 인덱스를 사용할 때는 인덱스 전체를 사용하거나 일부 인덱스만 사용합니다. 
* key_len은 이렇게 사용한 인덱스의 바이트 수를 의미함.
* UTF-8 캐릭터셋 기준으로 INT 4바이트, VARCHAR 3바이트

### ref
* 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 액세스 되었는지를 알려주는 정보.

### row
* sql문을 수행하고자 접근하는 데이터의 모든 행 수를 나타내는 예측 항목.
* `sql문의 최종 결과 건수와 비교해 rows수가 크게 차이 날 떄는 불필요하게 MySQL엔진까지 데이터를 많이 가져왔다는 뜻 -> 튜닝 대상`

### filtered
* sql문을 통해 DB 엔진으로 가져온 데이터 대상으로 필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지를 의미하는 항목.
* DB엔진으로 100건의 데이터를 가져왔다고 가졍했을때 조건에의해 10건이 필터링 되었다면 100/10 = 10 이라는 정보가 출력

### Extra
* sql문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목


