# 개념적인 튜닝 용어
## 오브젝트 스캔 유형
* 오브젝트 스캔 유형은 테이블 스캔과 인덱스 스캔으로 구분,
* 테이블 스캔은 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근.
* 인덱스 스캔은 인덱스로 테이블 데이터를 찾아가는 유형

### 테이블 풀 스킨
* 테이블 풀 스캔은 인덱스를 거치지 않고 테이블로 바로 직행해 처음부터 끝까지 모든 데이터를 읽는 방식
* where절의 조건문을 기준으로 활용할 수 있는 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 테이블 풀 스캔 방식을 사용
* 테이블 풀 스캔은 테이블의 모든 데이터를 읽어야 하므로 성능측면에서는 부정적

<br />

### 인덱스 범위 스캔
* 인덱스 범위 스캔은 말 그대로 인덱스 범위 기준으로 스캔한 뒤 스캔한 결과를 바탕으로 테이블 데이터 찾아감.
* sql에서 between, in, >, <, like 등의 조건문을 사용할 때 인덱스 범위 스캔이 발생
* 좁은 범위를 스캔할 때는 성능적으로 매우 효율적, 넓은 범위를 스캔할 때는 비효율적인 방식


<br />

### 인덱스 풀 스캔
* 인덱스 풀 스캔은 말 그대로 인덱스를 처음부터 끝까지 모두 스캔하는 방식
* 단, 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 sql 문에서 인덱스 풀 스캔이 수행 됨
* 인덱스 풀 스캔은 테이블에 접근하지 않으므로 테이블 풀 스캔보다는 효율적
* 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 범위를 최대한 줄이는 방향으로 튜닝 필요


<br />

### 인덱스 고유 스캔
* 인덱스 고유 스캔은 기본 키나 고유 인덱스로 테이블에 접근하는 방식.
* 인덱스를 사용하는 스캔 방식 중 가장 효율적 스캔 방법
* where 절에 = 조건으로 작성,해당 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 때 인덱스 고유 스캔이 발생
  
<br />

### 인덱스 루스 스캔
* 인덱스 루스 스캔은 인덱스의 피룡한 부분들만 골라 스캔하는 방식
* 인덱스 범위 스캔처럼 넓은 범위에 전부 접근하지 않고, where절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시
* 인덱스 루스 스캔은 보통 group by 구문이나 max(), min() 함수가 사용된 경우 발생
* `이미 오름차순으로 정렬된 인덱스 에서 최댓값이나 최솟값이 필요한 경우가 이에 해당`

<br />

### 인덱스 병합 스캔
* 인덱스 병합 스캔은 테이블 내에 생성된 인덱스들을 통합해서 스캔하는 방식
* where 절에 여러 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와 모두 활용하는 방식을 취함.
* 통합하는 방법으로는 union, intersection방식이 있으며 plan으로 확인 가능
* `인덱스 병합 스캔은 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸림.`
* 따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 sql 튜닝 하거나, sql문 자체를 독립된 하나의 인덱스만 수행하도록 변경하여 튜닝
 


## 응용 용어
### 선택도
* 선택도란 테이블의 특정 열을 기준으로 해당 열의 조건절에 따라 선택되는 데이터 비율을 의미.
* 만약 해당 열에 중복되는 데이터가 많다면 선택도가 높다.
* 해당 열에 중복되는 데이터가 적다면 선택도가 낮다.
* `낮은 선택도를 갖는 열은 데이터를 조회하는 sql문에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할때 주요 고려 대상`
> 선택도 = 선택한 데이터 건수 / 전체 데이터 건수  
> 선택도 = 1 / DISTINCT(count 열명)
> 

### 카디널리티
* 카디널리티의 사전적 정의는 하나의 데이터 유형으로 정의되는 데이터 행의 개수로 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수.
* 현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 활용

> 카디널리티 = 전체 데이터 건수 * 선택도

* 특정 열에 중복된 값이 많다면 카디널리티가 낮고,   
* 해당 열을 조회하면 상당수의 데이터를 거리지 못한 채 대량의 데이터가 출력되리라 예측

| a   | b  |
|-----|----|
| 1   | 1  |
| 1   |2|
| 1   |3|
| 1   |4|
| 1   |5|
| 2   |6|
| 2   |7|
| 2   |8|

* a열의 카디널리티는 낮고,
* b열의 카디널리티는 높다.

### 힌트
* 데이터를 빨리 찾을 수 있게 추가 정보를 전달하는 것
* 힌트는 아래와 같이 사용
```sql
SELECT 컬럼 
FROM 테이블 USE INDEX (인덱스명)
WHERE 조건
```
* 주요 힌트 목록

| 힌트            | 설명                         |
|---------------|----------------------------|
| STRAIGHT_JOIN | from 절에 작성된 테이블 순으로 조인을 유도 |
| USE INDEX     | 특정 인덱스를 사용하도록 유도           |
| IGNORE INDEX  | 특정 인덱스를 사용하지 않도록 유도        | 
| FORCE INDEX   | 특정 인덱스를 사용하도록 강하게 유도       |


* 주의사항 
* 힌트로 특정 인덱스를 사용하라고 명시 했는데 해당 인덱스가 삭제되면 에러 발생함.

# 실행계획
## 기본 실행 계획 항목 분석
### id 
* 실행 순서를 표시하는 숫자. SQL문이 수행되는 차례를 ID로 표기한 것으로, 조인할 때는 똑같은 ID가 표시됨
* ID가 작을수록 먼저 수행된 것이고 ID가 같은 값이면 조인이 이루어졌다고 해석

### select_type
* SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목 
* SELECT 문이 단순히 FROM절에 위치한 것인지, 서브쿼리인지, UNION 절로 묶인 SELECT 문인지 등의 정보 제공

#### | SIMPLE |
* UNION이나 내부 쿼리가 없는 SELECT 문이라는 걸 의미하는 유형입니다. (단순한 SELECT 구문으로만 작성된 경우)

#### | PRIMARY |
* 서브쿼리가 포함된 SQL 문이 있을 때 첫 번쨰 SELECT 문에 해당하는 구문에 표시되는 유형입니다.
* 서브쿼리를 감싸는 외부 쿼리이거나, UNION이 포함된 SQL 문에서 첫 번째로 SELECT 키워드가 작성된 구문에 표시됨.

#### | SUBQUERY |
* 독립적으로 수행되는 서브쿼리를 의미함.
* SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브쿼리일 경우에 해당함

#### | DERIVED |
* FROM 절에 작성된 서브쿼리라는 의미
* FROM 절의 별도 임시 테이블인 인라인 뷰를 말함.

#### | UNION |
* UNION이나 UNION ALL로 묶인 SELECT 문에서 첫 번째 SELECT 구문을 제외한 이후의 SELECT 구문에 해당함
* (UNION구문의 첫 번째 SELECT 절은 PRIMARY 유형으로 표시됨)

#### | UNION RESULT |
* UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력됩니다. 
* UNION은 출력 결과에 중복이 없는 유일한 속성을 가지므로 각 SELECT 절에서 데이터를 가져와 정렬하여 중복 체크하는 과정을 거칩니다. 
* 따라서 UNION RESULT는 별도의 메모리 또는 디스크에 임시 테이블을 만들어 중복을 제거하겠다는 의미로 해석할 수 있다.
* `UNION 구문으로 결합되기 전의 각 SELECT 문이 중복되지 않는 결과가 보장될 때는 UNION 구문 보다는 UNION ALL 구문으로 변경하는 것이 좋다.`

#### | DEPENDENT SUBQUERY |
* UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우
* UNION으로 연결된 단위 쿼리들 중에서 처음으로 작성한 단위 쿼리에 해당하는 경우.
* `UNION으로 연결되는 첫 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조- > 튜닝 대상`

#### | DEPENDENT UNION |
* UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블에 영향을 받는 경우
* UNION으로 연결된 단위 쿼리들 중에서 두 번째 단위 쿼리에 해당되는 경우.
* `UNION으로 연결되는 두 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조- > 튜닝 대상`

#### | UNCACHEABLE SUBQUERY |
* 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형
* 해당 서브쿼리 안에 사용자 정의 함수나 사용자 변수가 포함되거나, RAND(), UUID()함수 등을 사용하여 매번 조회 시 마다 다른 결과를 반환하는 경우
* `만약 자주 호출되는 SQL문이라면 메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 튜닝 고려`

#### | MATERIALIZED |
* IN절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 떄 출력되는 유형.
* 즉 IN 절의 서브쿼리를 임시 테이블로 만들어서 조인 작업을 수행하는 것

### table
* 테이블명을 표시하는 항목
* 실행 계획 정보에서 테이블명이나 테이블 별칭을 출력
* 서브쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 subquery, derived라고 표시됨.


### partitions
* 실행 게획의 부가 정보로, 데이터가 저장된 논리적인 영역을 표시.
* 만약 너무 많은 영역의 파티션에 접근하는 것으로 출력된다면 파티션 정의 튜닝 고려.


### type
* 테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공함
* 테이블을 처음부터 끝까지 전부 확인할지 아니면 인덱스를 통해 바로 데이터를 찾아갈지 등을 해석할 수 있다.

#### | system |
* 테이블에 데이터가 없거나 한 개만 있는 경우로, 성능상 최상의 type이라고 할 수 있습니다.

#### | const |
* 조회되는 데이터가 단 1건일 때 출력되는 유형으로, 성능상 매우 유리한 방식.
* 고유 인덱스나 기본 키를 사용하여 단 1건의 데이터에만 접근하면 되므로 속도나 리소스 사용 측면에서 매우 유리한 방식.

#### | eq_ref |
* 조인이 수행될 떄 드리븐 테이블의 데이터에 접근하며 고유 인덱스 또는 기본 키로 단 1건의 데이터를 조회하는 방식.
* 드라이빙 테이블과의 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 떄 성능상 가장 유리.

#### | ref |
* 조인을 수행할 떄 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미
* 즉 조인이 수행될때 일대다 관계가 되므로, 드라이빙 테이블의 1개 값이 드리븐 테이블에서는 2개 이상의 데이터로 존재함.
* 